//
//  ImageShareHelper.swift
//  SpeedType
//
//  Created by Assistant on 2024.
//

import AppKit
import SwiftUI
import UserNotifications

// MARK: - Image Layout Configuration

private enum ImageLayout {
  static let width: CGFloat = 600
  static let height: CGFloat = 400
  static let padding: CGFloat = 40

  enum Font {
    static let title = NSFont.systemFont(ofSize: 28, weight: .bold)
    static let icon = NSFont.systemFont(ofSize: 24)
    static let value = NSFont.systemFont(ofSize: 32, weight: .bold)
    static let label = NSFont.systemFont(ofSize: 14, weight: .medium)
    static let watermark = NSFont.systemFont(ofSize: 14, weight: .medium)
  }

  enum Offset {
    static let titleBottom: CGFloat = 20
    static let metricsFromTitle: CGFloat = 60
    static let secondaryFromPrimary: CGFloat = 80
    static let iconValueGap: CGFloat = 10
    static let iconYOffset: CGFloat = 40
    static let valueYOffset: CGFloat = 35
    static let labelYOffset: CGFloat = 10
  }
}

// MARK: - Text Attributes Helper

private enum TextStyle {
  case title, icon, value, label, watermark

  var attributes: [NSAttributedString.Key: Any] {
    switch self {
    case .title:
      [.font: ImageLayout.Font.title, .foregroundColor: NSColor.labelColor]
    case .icon:
      [.font: ImageLayout.Font.icon, .foregroundColor: NSColor.labelColor]
    case .value:
      [.font: ImageLayout.Font.value, .foregroundColor: NSColor.labelColor]
    case .label:
      [.font: ImageLayout.Font.label, .foregroundColor: NSColor.secondaryLabelColor]
    case .watermark:
      [.font: ImageLayout.Font.watermark, .foregroundColor: NSColor.secondaryLabelColor]
    }
  }
}

// MARK: - Metric Data

private struct MetricData {
  let icon: String
  let value: String
  let label: String
}

// MARK: - ImageShareHelper

class ImageShareHelper {
  /// ç”Ÿæˆå¸¦æ°´å°çš„ç»“æžœå›¾ç‰‡
  static func generateResultImage(testState: TypingTestState) -> NSImage? {
    let size = NSSize(width: ImageLayout.width, height: ImageLayout.height)
    let image = NSImage(size: size)

    image.lockFocus()
    NSColor.windowBackgroundColor.setFill()
    NSRect(origin: .zero, size: size).fill()
    drawResultContent(testState: testState, in: NSRect(origin: .zero, size: size))
    image.unlockFocus()

    return image
  }

  // MARK: - Private Drawing Methods

  private static func drawResultContent(testState: TypingTestState, in rect: NSRect) {
    let contentRect = rect.insetBy(dx: ImageLayout.padding, dy: ImageLayout.padding)

    let titleY = drawTitle(in: contentRect)
    let primaryMetricsY = titleY - ImageLayout.Offset.metricsFromTitle
    let secondaryMetricsY = primaryMetricsY - ImageLayout.Offset.secondaryFromPrimary

    let primaryMetrics = [
      MetricData(icon: "âš¡", value: String(format: "%.1f", testState.wpm), label: "WPM"),
      MetricData(icon: "ðŸŽ¯", value: "\(testState.accuracy)%", label: "å‡†ç¡®çŽ‡"),
    ]

    let secondaryMetrics = [
      MetricData(icon: "ðŸ“", value: "\(testState.currentIndex)", label: "å­—ç¬¦"),
      MetricData(icon: "â±ï¸", value: String(format: "%.3f", testState.elapsedTime), label: "æ—¶é—´"),
    ]

    drawMetrics(primaryMetrics, y: primaryMetricsY, in: contentRect)
    drawMetrics(secondaryMetrics, y: secondaryMetricsY, in: contentRect)
    drawWatermark(in: contentRect)
  }

  private static func drawTitle(in rect: NSRect) -> CGFloat {
    let title = "SpeedType æµ‹è¯•ç»“æžœ"
    let titleSize = title.size(withAttributes: TextStyle.title.attributes)
    let titleRect = NSRect(
      x: rect.midX - titleSize.width / 2,
      y: rect.maxY - titleSize.height - ImageLayout.Offset.titleBottom,
      width: titleSize.width,
      height: titleSize.height
    )
    title.draw(in: titleRect, withAttributes: TextStyle.title.attributes)
    return titleRect.minY
  }

  private static func drawMetrics(_ metrics: [MetricData], y: CGFloat, in rect: NSRect) {
    let positions = [rect.minX + 50, rect.midX - 50]
    for (index, metric) in metrics.enumerated() where index < positions.count {
      drawMetric(metric, at: NSPoint(x: positions[index], y: y))
    }
  }

  private static func drawMetric(_ metric: MetricData, at point: NSPoint) {
    let iconSize = metric.icon.size(withAttributes: TextStyle.icon.attributes)

    metric.icon.draw(
      at: NSPoint(x: point.x, y: point.y + ImageLayout.Offset.iconYOffset),
      withAttributes: TextStyle.icon.attributes
    )

    metric.value.draw(
      at: NSPoint(
        x: point.x + iconSize.width + ImageLayout.Offset.iconValueGap,
        y: point.y + ImageLayout.Offset.valueYOffset
      ),
      withAttributes: TextStyle.value.attributes
    )

    metric.label.draw(
      at: NSPoint(
        x: point.x + iconSize.width + ImageLayout.Offset.iconValueGap,
        y: point.y + ImageLayout.Offset.labelYOffset
      ),
      withAttributes: TextStyle.label.attributes
    )
  }

  private static func drawWatermark(in rect: NSRect) {
    let watermark = "Generated by SpeedType"
    let size = watermark.size(withAttributes: TextStyle.watermark.attributes)
    watermark.draw(
      at: NSPoint(x: rect.maxX - size.width, y: rect.minY),
      withAttributes: TextStyle.watermark.attributes
    )
  }

  // MARK: - Sharing Methods

  static func shareImage(_ image: NSImage) {
    guard let pngData = image.pngData else { return }

    let tempURL = FileManager.default.temporaryDirectory
      .appendingPathComponent("SpeedType_Result_\(Date().timeIntervalSince1970).png")

    guard let _ = try? pngData.write(to: tempURL) else {
      copyToClipboard(data: pngData)
      return
    }

    showShareMenu(for: tempURL)
  }

  private static func showShareMenu(for url: URL) {
    guard let window = NSApplication.shared.keyWindow else { return }

    let picker = NSSharingServicePicker(items: [url])
    let shareMenuItem = picker.standardShareMenuItem
    let location = NSApplication.shared.currentEvent?.locationInWindow
      ?? NSPoint(x: window.frame.width / 2, y: window.frame.height / 2)

    let menu = NSMenu()
    menu.addItem(shareMenuItem)
    menu.popUp(positioning: shareMenuItem, at: location, in: window.contentView)
  }

  private static func copyToClipboard(data: Data) {
    let pasteboard = NSPasteboard.general
    pasteboard.clearContents()
    pasteboard.setData(data, forType: .png)

    let content = UNMutableNotificationContent()
    content.title = "SpeedType"
    content.body = "æµ‹è¯•ç»“æžœå›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿"
    content.sound = .default

    let request = UNNotificationRequest(identifier: "speedtype_share", content: content, trigger: nil)
    UNUserNotificationCenter.current().add(request) { _ in }
  }
}

// MARK: - NSImage Extension

private extension NSImage {
  var pngData: Data? {
    guard let tiffData = tiffRepresentation,
          let bitmapRep = NSBitmapImageRep(data: tiffData)
    else { return nil }
    return bitmapRep.representation(using: .png, properties: [:])
  }
}
